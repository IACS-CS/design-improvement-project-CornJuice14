/* This code drives the design improvement showcase and is NOT meant to be modified. */

/* Attribution: this code was generated by Claude Haiku 4.5 */

/**
 * Design Improvement Showcase - Responsive Scaling
 *
 * This script handles scaling designs to fit the viewport while maintaining
 * their specified dimensions. If a design is larger than the available space,
 * it scales down using CSS transforms.
 */

class DesignScaler {
  constructor() {
    this.designs = [];
    this.init();
  }

  init() {
    // Find all elements that need scaling
    this.designs = document.querySelectorAll(".design-viewport");

    // Initial setup and observation
    this.setupDesigns();
    this.observeChanges();

    // Handle window resize
    window.addEventListener("resize", () => this.scaleDesigns());

    // Handle orientation change
    window.addEventListener("orientationchange", () => {
      setTimeout(() => this.scaleDesigns(), 100);
    });
  }

  setupDesigns() {
    this.designs.forEach((viewport) => {
      const designElement = viewport.querySelector(".design-image, .my-design");
      if (designElement) {
        // For images, prefer the intrinsic (natural) size and attach the original
        // dimensions to the viewport so we can scale the box instead of the image.
        if (designElement.tagName === "IMG") {
          const width =
            designElement.naturalWidth ||
            parseInt(getComputedStyle(viewport).width, 10) ||
            960;
          const height =
            designElement.naturalHeight ||
            parseInt(getComputedStyle(viewport).height, 10) ||
            720;

          viewport.dataset.originalWidth = width;
          viewport.dataset.originalHeight = height;

          // Mark the image so it's not transformed directly
          designElement.dataset.noTransform = "true";
        } else {
          // Store original dimensions from .design-size class for non-image designs
          const width = parseInt(getComputedStyle(designElement).width, 10);
          const height = parseInt(getComputedStyle(designElement).height, 10);

          designElement.dataset.originalWidth = width;
          designElement.dataset.originalHeight = height;
        }
      }
    });

    this.scaleDesigns();
  }

  scaleDesigns() {
    this.designs.forEach((viewport) => {
      const designElement = viewport.querySelector(".design-image, .my-design");
      if (!designElement) return;

      let elementToScale = designElement;
      let originalWidth = null;
      let originalHeight = null;

      // If it's an image, we scale the viewport (box) instead of the image itself
      if (designElement.tagName === "IMG") {
        elementToScale = viewport;
        originalWidth = parseInt(viewport.dataset.originalWidth, 10);
        originalHeight = parseInt(viewport.dataset.originalHeight, 10);
      } else {
        originalWidth = parseInt(designElement.dataset.originalWidth, 10);
        originalHeight = parseInt(designElement.dataset.originalHeight, 10);
      }

      if (!originalWidth || !originalHeight) {
        // Fallback to computed size
        originalWidth =
          originalWidth ||
          parseInt(getComputedStyle(elementToScale).width, 10) ||
          960;
        originalHeight =
          originalHeight ||
          parseInt(getComputedStyle(elementToScale).height, 10) ||
          720;
      }

      // Get available space. Prefer the parent wrapper size so both original and improved designs
      // can take advantage of the available container area when being scaled.
      let availableWidth, availableHeight;
      const wrapper = viewport.parentElement;
      availableWidth =
        (wrapper ? wrapper.clientWidth : viewport.clientWidth) - 32; // Account for padding
      availableHeight =
        (wrapper ? wrapper.clientHeight : viewport.clientHeight) - 32;

      // Calculate scale factor
      let scale = 1;

      if (originalWidth > availableWidth) {
        scale = Math.min(scale, availableWidth / originalWidth);
      }

      if (originalHeight > availableHeight) {
        scale = Math.min(scale, availableHeight / originalHeight);
      }

      // Apply scaling: for images, set the viewport dimensions so the image is never cropped;
      // for improved designs (.my-design), use transforms but measure against the wrapper so the
      // full design is visible and centered.
      if (designElement.tagName === "IMG") {
        const scaledW = Math.max(1, Math.round(originalWidth * scale));
        const scaledH = Math.max(1, Math.round(originalHeight * scale));
        viewport.style.width = scaledW + "px";
        viewport.style.height = scaledH + "px";
        viewport.style.transform = "none";
      } else {
        // Reset viewport dimensions in case it was previously resized for an image
        viewport.style.width = "";
        viewport.style.height = "";

        // Apply transform scaling to the design element and center it
        if (scale < 1) {
          elementToScale.style.transform = `scale(${scale.toFixed(3)})`;
        } else {
          elementToScale.style.transform = "scale(1)";
        }
        elementToScale.style.transformOrigin = "center center";
      }
    });
  }

  observeChanges() {
    // Watch for changes in the design elements (if content is dynamically added)
    const observer = new MutationObserver(() => {
      this.scaleDesigns();
    });

    this.designs.forEach((viewport) => {
      observer.observe(viewport, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ["class", "style"],
      });
    });
  }
}

/**
 * Design Modal - Full-size design viewer
 */
class DesignModal {
  constructor() {
    this.modal = document.getElementById("designModal");
    this.backdrop = this.modal.querySelector(".modal-backdrop");
    this.closeBtn = this.modal.querySelector(".modal-close-btn");
    this.viewport = this.modal.querySelector("#modalViewport");

    this.addSvgIcons();
    this.setupEventListeners();
  }

  addSvgIcons() {
    // Add expand icons to popout buttons
    document.querySelectorAll(".popout-btn").forEach((btn) => {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", "20");
      svg.setAttribute("height", "20");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.setAttribute("fill", "none");
      svg.setAttribute("stroke", "currentColor");
      svg.setAttribute("stroke-width", "2");

      const path = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      path.setAttribute(
        "d",
        "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
      );
      svg.appendChild(path);
      btn.appendChild(svg);
    });

    // Add close icon to modal close button
    const closeSvg = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "svg"
    );
    closeSvg.setAttribute("width", "24");
    closeSvg.setAttribute("height", "24");
    closeSvg.setAttribute("viewBox", "0 0 24 24");
    closeSvg.setAttribute("fill", "none");
    closeSvg.setAttribute("stroke", "currentColor");
    closeSvg.setAttribute("stroke-width", "2");

    const line1 = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );
    line1.setAttribute("x1", "18");
    line1.setAttribute("y1", "6");
    line1.setAttribute("x2", "6");
    line1.setAttribute("y2", "18");
    closeSvg.appendChild(line1);

    const line2 = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "line"
    );
    line2.setAttribute("x1", "6");
    line2.setAttribute("y1", "6");
    line2.setAttribute("x2", "18");
    line2.setAttribute("y2", "18");
    closeSvg.appendChild(line2);

    this.closeBtn.appendChild(closeSvg);
  }

  setupEventListeners() {
    // Pop-out button listeners
    document.querySelectorAll(".popout-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const target = btn.dataset.target;
        this.openModal(target);
      });
    });

    // Close modal listeners
    this.closeBtn.addEventListener("click", () => this.closeModal());
    this.backdrop.addEventListener("click", () => this.closeModal());

    // Keyboard escape to close
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && this.modal.classList.contains("active")) {
        this.closeModal();
      }
    });
  }

  openModal(target) {
    // Clear previous content
    this.viewport.innerHTML = "";

    if (target === "original") {
      const originalImg = document.querySelector(".design-image");
      if (originalImg.src) {
        const imgClone = originalImg.cloneNode(true);
        imgClone.style.transform = "scale(1)";
        imgClone.style.maxWidth = "none";
        imgClone.style.maxHeight = "none";
        imgClone.style.width = "auto";
        imgClone.style.height = "auto";
        this.viewport.appendChild(imgClone);
      }
    } else if (target === "improvement") {
      const designContent = document.querySelector(".my-design");
      if (designContent) {
        const designClone = designContent.cloneNode(true);
        designClone.style.transform = "scale(1)";
        designClone.style.maxWidth = "none";
        designClone.style.maxHeight = "none";
        designClone.classList.remove("design-size");

        // Get original dimensions
        const originalWidth = designClone.dataset.originalWidth;
        const originalHeight = designClone.dataset.originalHeight;
        if (originalWidth) designClone.style.width = originalWidth + "px";
        if (originalHeight) designClone.style.height = originalHeight + "px";

        this.viewport.appendChild(designClone);
      }
    }

    // Show modal
    this.modal.classList.add("active");
    document.body.style.overflow = "hidden";
  }

  closeModal() {
    this.modal.classList.remove("active");
    document.body.style.overflow = "";
    this.viewport.innerHTML = "";
  }
}

// Initialize when DOM is ready
if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", () => {
    new DesignScaler();
    new DesignModal();
  });
} else {
  new DesignScaler();
  new DesignModal();
}
